================================================================================
PAYMENT PLAN EDITOR - COMPLETE SOURCE CODE DOCUMENTATION
================================================================================
Generated: January 9, 2026 (Version 1.2)
Total Lines: ~5,200 lines across 5 source files
================================================================================

TABLE OF CONTENTS
-----------------
1. PaymentPlanEditorController.cls (Apex Controller) - Lines 1-1340
2. PaymentPlanEditorControllerTest.cls (Test Class) - Lines 1-950
3. paymentPlanEditor.js (LWC JavaScript) - Lines 1-1387
4. paymentPlanEditor.html (LWC Template) - Lines 1-462
5. paymentPlanEditor.css (LWC Styles) - Lines 1-1007

================================================================================
FILE 1: PaymentPlanEditorController.cls
================================================================================
Path: force-app/main/default/classes/PaymentPlanEditorController.cls
Lines: 1340

--------------------------------------------------------------------------------
/**
 * @description Controller for Payment Plan Editor LWC
 * Handles CRUD operations for Payment Plans and Payment Schedule Items
 * with version management support
 */
public with sharing class PaymentPlanEditorController {

    /**
     * @description Wrapper class for Payment Plan with Schedule Items
     */
    public class PaymentPlanWrapper {
        @AuraEnabled public PaymentPlan__c paymentPlan { get; set; }
        @AuraEnabled public List<ScheduleItemWrapper> scheduleItems { get; set; }
        @AuraEnabled public Integer versionNumber { get; set; }
        @AuraEnabled public String versionStatus { get; set; }
        @AuraEnabled public Boolean isLatestVersion { get; set; }

        public PaymentPlanWrapper() {
            this.scheduleItems = new List<ScheduleItemWrapper>();
        }
    }

    /**
     * @description Wrapper for schedule items with row metadata
     */
    public class ScheduleItemWrapper {
        @AuraEnabled public String id { get; set; }
        @AuraEnabled public Integer rowNumber { get; set; }
        @AuraEnabled public String draftNumber { get; set; }
        @AuraEnabled public Date paymentDate { get; set; }
        @AuraEnabled public Decimal draftAmount { get; set; }
        @AuraEnabled public Decimal retainerFee { get; set; }
        @AuraEnabled public Decimal setupFee { get; set; }
        @AuraEnabled public Decimal programFee { get; set; }
        @AuraEnabled public Decimal bankingFee { get; set; }
        @AuraEnabled public Decimal banking2Fee { get; set; }
        @AuraEnabled public Decimal alertAmount { get; set; }
        @AuraEnabled public Decimal savingsBalance { get; set; }
        @AuraEnabled public Decimal toEscrowAmount { get; set; }
        @AuraEnabled public String status { get; set; }
        @AuraEnabled public Boolean isModified { get; set; }
        @AuraEnabled public Boolean isNew { get; set; }
        @AuraEnabled public Boolean isDeleted { get; set; }

        public ScheduleItemWrapper() {
            this.isModified = false;
            this.isNew = false;
            this.isDeleted = false;
        }
    }

    /**
     * @description Get the latest active Payment Plan for an Opportunity
     * @param opportunityId The Opportunity ID
     * @return PaymentPlanWrapper containing plan and schedule items
     */
    @AuraEnabled(cacheable=true)
    public static PaymentPlanWrapper getLatestPaymentPlan(Id opportunityId) {
        try {
            if (opportunityId == null) {
                return null;
            }

            List<PaymentPlan__c> plans = [
                SELECT Id, Name, Opportunity__c, Contract__c, Program_Type__c,
                       Total_Debt__c, Settlement_Percentage__c, Program_Fee_Percentage__c,
                       Total_Program_Cost__c, Weekly_Payment__c, Monthly_Payment__c,
                       Number_of_Payments__c, First_Payment_Date__c, Status__c,
                       Version_Number__c, Version_Status__c, Is_Active__c,
                       Banking_Fee__c, Bank2_Fee__c, Setup_Fee__c, Setup_Fee_Payments__c,
                       Current_Payment__c, No_Fee_Program__c, Preferred_Day_of_Week__c,
                       Calculation_Timestamp__c, Previous_Version__c, Source__c,
                       Version_Type__c, Version_Notes__c, Schedule_Item_Count__c
                FROM PaymentPlan__c
                WHERE Opportunity__c = :opportunityId
                  AND Is_Active__c = true
                ORDER BY Version_Number__c DESC, CreatedDate DESC
                LIMIT 1
            ];

            if (plans.isEmpty()) {
                return null;
            }

            return buildPaymentPlanWrapper(plans[0], true);

        } catch (Exception e) {
            throw new AuraHandledException('Error fetching payment plan: ' + e.getMessage());
        }
    }

    /**
     * @description Get all active Payment Plans for an Opportunity
     * Returns a single wrapper with all active plans displayed as rows (using PaymentPlan__c fields directly)
     * @param opportunityId The Opportunity ID
     * @return List of PaymentPlanWrapper containing consolidated plan data
     */
    @AuraEnabled(cacheable=true)
    public static List<PaymentPlanWrapper> getActivePaymentPlans(Id opportunityId) {
        try {
            if (opportunityId == null) {
                return new List<PaymentPlanWrapper>();
            }

            // Get all active plans ordered by First Payment Date
            List<PaymentPlan__c> plans = [
                SELECT Id, Name, Opportunity__c, Contract__c, Program_Type__c,
                       Total_Debt__c, Settlement_Percentage__c, Program_Fee_Percentage__c,
                       Total_Program_Cost__c, Weekly_Payment__c, Monthly_Payment__c,
                       Number_of_Payments__c, First_Payment_Date__c, Status__c,
                       Version_Number__c, Version_Status__c, Is_Active__c,
                       Banking_Fee__c, Bank2_Fee__c, Setup_Fee__c, Setup_Fee_Payments__c,
                       Current_Payment__c, No_Fee_Program__c, Preferred_Day_of_Week__c,
                       Calculation_Timestamp__c, Previous_Version__c, Source__c,
                       Version_Type__c, Version_Notes__c, Schedule_Item_Count__c,
                       Program_Fee_Amount__c
                FROM PaymentPlan__c
                WHERE Opportunity__c = :opportunityId
                  AND Is_Active__c = true
                ORDER BY First_Payment_Date__c ASC, Name ASC
            ];

            if (plans.isEmpty()) {
                return new List<PaymentPlanWrapper>();
            }

            // Create a single consolidated wrapper using the first plan as the header
            PaymentPlanWrapper wrapper = new PaymentPlanWrapper();
            wrapper.paymentPlan = plans[0];
            wrapper.versionNumber = plans[0].Version_Number__c != null ? plans[0].Version_Number__c.intValue() : 1;
            wrapper.versionStatus = plans[0].Version_Status__c;
            wrapper.isLatestVersion = true;

            // Build schedule items directly from PaymentPlan__c records
            Integer rowNum = 1;
            for (PaymentPlan__c plan : plans) {
                wrapper.scheduleItems.add(buildScheduleItemFromPlan(plan, rowNum++));
            }

            // Return as single-element list so LWC doesn't show plan selector
            List<PaymentPlanWrapper> wrappers = new List<PaymentPlanWrapper>();
            wrappers.add(wrapper);

            return wrappers;

        } catch (Exception e) {
            throw new AuraHandledException('Error fetching active payment plans: ' + e.getMessage());
        }
    }

    /**
     * @description Build ScheduleItemWrapper directly from PaymentPlan__c record
     * Maps PaymentPlan__c fields to the schedule item display format
     */
    private static ScheduleItemWrapper buildScheduleItemFromPlan(PaymentPlan__c plan, Integer rowNum) {
        ScheduleItemWrapper wrapper = new ScheduleItemWrapper();
        wrapper.id = plan.Id;
        wrapper.rowNumber = rowNum;
        wrapper.draftNumber = plan.Name; // Draft # = Plan Name (PP-00052, etc.)
        wrapper.paymentDate = plan.First_Payment_Date__c; // Date
        wrapper.draftAmount = plan.Weekly_Payment__c != null ? plan.Weekly_Payment__c : 0; // Draft
        wrapper.retainerFee = 0; // Retainer = 0.00 (hardcoded)
        wrapper.setupFee = plan.Setup_Fee__c != null ? plan.Setup_Fee__c : 0; // Setup
        wrapper.programFee = plan.Program_Fee_Amount__c != null ? plan.Program_Fee_Amount__c : 0; // Program
        wrapper.bankingFee = plan.Banking_Fee__c != null ? plan.Banking_Fee__c : 0; // Banking
        wrapper.banking2Fee = plan.Bank2_Fee__c != null ? plan.Bank2_Fee__c : 0; // Banking2
        wrapper.alertAmount = 0; // Alert = 0.00 (hardcoded)

        // No calculation - Savings_Balance__c only exists on Payment_Schedule_Item__c, not PaymentPlan__c
        wrapper.savingsBalance = 0;
        wrapper.toEscrowAmount = 0;
        // All active payment plans should show Status as 'Active'
        wrapper.status = 'Active';
        return wrapper;
    }

    /**
     * @description Get all versions of Payment Plans for an Opportunity
     * @param opportunityId The Opportunity ID
     * @return List of PaymentPlanWrapper for version history
     */
    @AuraEnabled(cacheable=true)
    public static List<PaymentPlanWrapper> getPaymentPlanVersions(Id opportunityId) {
        try {
            if (opportunityId == null) {
                return new List<PaymentPlanWrapper>();
            }

            List<PaymentPlan__c> plans = [
                SELECT Id, Name, Version_Number__c, Version_Status__c, Is_Active__c,
                       CreatedDate, LastModifiedDate, Status__c
                FROM PaymentPlan__c
                WHERE Opportunity__c = :opportunityId
                ORDER BY Version_Number__c DESC
            ];

            List<PaymentPlanWrapper> wrappers = new List<PaymentPlanWrapper>();
            Decimal latestVersion = plans.isEmpty() ? 0 :
                (plans[0].Version_Number__c != null ? plans[0].Version_Number__c : 1);

            for (PaymentPlan__c plan : plans) {
                PaymentPlanWrapper wrapper = new PaymentPlanWrapper();
                wrapper.paymentPlan = plan;
                wrapper.versionNumber = plan.Version_Number__c != null ? plan.Version_Number__c.intValue() : 1;
                wrapper.versionStatus = plan.Version_Status__c;
                wrapper.isLatestVersion = (plan.Version_Number__c == latestVersion);
                wrappers.add(wrapper);
            }

            return wrappers;

        } catch (Exception e) {
            throw new AuraHandledException('Error fetching payment plan versions: ' + e.getMessage());
        }
    }

    /**
     * @description Create a new manual version of the Payment Plan
     * Clones the current plan and its schedule items
     * @param currentPlanId The current Payment Plan ID to clone
     * @return PaymentPlanWrapper for the new version
     */
    @AuraEnabled
    public static PaymentPlanWrapper createManualVersion(Id currentPlanId) {
        Savepoint sp = Database.setSavepoint();
        try {
            if (currentPlanId == null) {
                throw new AuraHandledException('Plan ID is required');
            }

            PaymentPlan__c currentPlan = [
                SELECT Id, Name, Opportunity__c, Contract__c, Program_Type__c,
                       Total_Debt__c, Settlement_Percentage__c, Program_Fee_Percentage__c,
                       Total_Program_Cost__c, Weekly_Payment__c, Monthly_Payment__c,
                       Number_of_Payments__c, First_Payment_Date__c, Status__c,
                       Version_Number__c, Version_Status__c, Is_Active__c,
                       Banking_Fee__c, Bank2_Fee__c, Setup_Fee__c, Setup_Fee_Payments__c,
                       Current_Payment__c, No_Fee_Program__c, Preferred_Day_of_Week__c,
                       Schedule_Item_Count__c
                FROM PaymentPlan__c
                WHERE Id = :currentPlanId
                LIMIT 1
            ];

            Decimal newVersionNumber = currentPlan.Version_Number__c != null ?
                currentPlan.Version_Number__c + 1 : 2;

            // Clone the plan as Draft (user must activate manually)
            PaymentPlan__c newPlan = currentPlan.clone(false, true, false, false);
            newPlan.Version_Number__c = newVersionNumber;
            newPlan.Version_Status__c = 'Draft';
            newPlan.Is_Active__c = false;
            newPlan.Previous_Version__c = currentPlan.Id;
            newPlan.Version_Type__c = 'Revision';
            newPlan.Source__c = 'UI';
            newPlan.Version_Notes__c = 'Manual version created on ' + DateTime.now().format();
            newPlan.Calculation_Timestamp__c = DateTime.now();
            insert newPlan;

            // Clone schedule items
            List<Payment_Schedule_Item__c> currentItems = [
                SELECT Id, Payment_Number__c, Draft_Number__c, Payment_Date__c,
                       Total_Payment__c, Net_Draft_Amount__c, Retainer_Fee_Amount__c,
                       Setup_Fee_Amount__c, Program_Fee_Amount__c, Banking_Fee_Amount__c,
                       Bank2_Fee_Amount__c, Additional_Products_Amount__c, Status__c,
                       Savings_Balance__c, To_Escrow_Amount__c
                FROM Payment_Schedule_Item__c
                WHERE Payment_Plan__c = :currentPlanId
                ORDER BY Payment_Number__c ASC
            ];

            List<Payment_Schedule_Item__c> newItems = new List<Payment_Schedule_Item__c>();
            for (Payment_Schedule_Item__c item : currentItems) {
                Payment_Schedule_Item__c newItem = item.clone(false, true, false, false);
                newItem.Payment_Plan__c = newPlan.Id;
                // Keep the original status
                newItems.add(newItem);
            }

            if (!newItems.isEmpty()) {
                insert newItems;
            }

            return getPaymentPlanById(newPlan.Id);

        } catch (Exception e) {
            Database.rollback(sp);
            throw new AuraHandledException('Error creating manual version: ' + e.getMessage());
        }
    }

    /**
     * @description Get Payment Plan by ID with schedule items
     * @param planId The Payment Plan ID
     * @return PaymentPlanWrapper
     */
    @AuraEnabled
    public static PaymentPlanWrapper getPaymentPlanById(Id planId) {
        try {
            if (planId == null) {
                throw new AuraHandledException('Error: Plan ID is required');
            }

            PaymentPlan__c plan = [
                SELECT Id, Name, Opportunity__c, Contract__c, Program_Type__c,
                       Total_Debt__c, Settlement_Percentage__c, Program_Fee_Percentage__c,
                       Total_Program_Cost__c, Weekly_Payment__c, Monthly_Payment__c,
                       Number_of_Payments__c, First_Payment_Date__c, Status__c,
                       Version_Number__c, Version_Status__c, Is_Active__c,
                       Banking_Fee__c, Bank2_Fee__c, Setup_Fee__c, Setup_Fee_Payments__c,
                       Current_Payment__c, No_Fee_Program__c, Preferred_Day_of_Week__c,
                       Calculation_Timestamp__c, Previous_Version__c, Source__c,
                       Version_Type__c, Version_Notes__c, Schedule_Item_Count__c
                FROM PaymentPlan__c
                WHERE Id = :planId
                LIMIT 1
            ];

            return buildPaymentPlanWrapper(plan, true);

        } catch (Exception e) {
            throw new AuraHandledException('Error fetching payment plan: ' + e.getMessage());
        }
    }

    /**
     * @description Save changes to schedule items (updates, inserts, deletes)
     * @param planId The Payment Plan ID
     * @param items List of ScheduleItemWrapper objects from LWC
     * @return Updated PaymentPlanWrapper
     */
    @AuraEnabled
    public static PaymentPlanWrapper saveScheduleItems(Id planId, List<ScheduleItemWrapper> items) {
        Savepoint sp = Database.setSavepoint();
        try {
            if (planId == null || items == null || items.isEmpty()) {
                throw new AuraHandledException('Plan ID and items are required');
            }

            List<Payment_Schedule_Item__c> toUpdate = new List<Payment_Schedule_Item__c>();
            List<Payment_Schedule_Item__c> toInsert = new List<Payment_Schedule_Item__c>();
            List<Id> toDelete = new List<Id>();

            for (ScheduleItemWrapper item : items) {
                if (item.isDeleted && String.isNotBlank(item.id)) {
                    toDelete.add(item.id);
                } else if (item.isNew && String.isBlank(item.id)) {
                    Payment_Schedule_Item__c newItem = new Payment_Schedule_Item__c();
                    newItem.Payment_Plan__c = planId;
                    mapWrapperToRecord(item, newItem);
                    toInsert.add(newItem);
                } else if (item.isModified && String.isNotBlank(item.id)) {
                    Payment_Schedule_Item__c updateItem = new Payment_Schedule_Item__c(Id = item.id);
                    mapWrapperToRecord(item, updateItem);
                    toUpdate.add(updateItem);
                }
            }

            // Perform DML in order: delete, update, insert
            if (!toDelete.isEmpty()) {
                delete [SELECT Id FROM Payment_Schedule_Item__c WHERE Id IN :toDelete];
            }
            if (!toUpdate.isEmpty()) {
                update toUpdate;
            }
            if (!toInsert.isEmpty()) {
                insert toInsert;
            }

            // Update plan timestamp and item count
            Integer itemCount = [SELECT COUNT() FROM Payment_Schedule_Item__c WHERE Payment_Plan__c = :planId];
            PaymentPlan__c plan = new PaymentPlan__c(Id = planId);
            plan.Calculation_Timestamp__c = DateTime.now();
            plan.Schedule_Item_Count__c = itemCount;
            update plan;

            return getPaymentPlanById(planId);

        } catch (Exception e) {
            Database.rollback(sp);
            throw new AuraHandledException('Error saving schedule items: ' + e.getMessage());
        }
    }

    /**
     * @description Add a new blank payment row
     * @param planId The Payment Plan ID
     * @param afterRowNumber Insert after this row number
     * @return The new ScheduleItemWrapper
     */
    @AuraEnabled
    public static ScheduleItemWrapper addPaymentRow(Id planId, Integer afterRowNumber) {
        try {
            if (planId == null) {
                throw new AuraHandledException('Plan ID is required');
            }

            // Get the last payment to calculate next date and number
            List<Payment_Schedule_Item__c> lastItems = [
                SELECT Payment_Date__c, Payment_Number__c
                FROM Payment_Schedule_Item__c
                WHERE Payment_Plan__c = :planId
                ORDER BY Payment_Number__c DESC
                LIMIT 1
            ];

            // Get default banking fee from plan
            PaymentPlan__c plan = [
                SELECT Banking_Fee__c
                FROM PaymentPlan__c
                WHERE Id = :planId
                LIMIT 1
            ];

            Date nextDate = Date.today().addDays(7);
            Decimal nextNumber = 1;

            if (!lastItems.isEmpty()) {
                if (lastItems[0].Payment_Date__c != null) {
                    nextDate = lastItems[0].Payment_Date__c.addDays(7);
                }
                nextNumber = lastItems[0].Payment_Number__c != null ?
                    lastItems[0].Payment_Number__c + 1 : (afterRowNumber != null ? afterRowNumber + 1 : 1);
            }

            Decimal defaultBankingFee = plan.Banking_Fee__c != null ? plan.Banking_Fee__c : 15.00;

            // Create new item
            Payment_Schedule_Item__c newItem = new Payment_Schedule_Item__c();
            newItem.Payment_Plan__c = planId;
            newItem.Payment_Number__c = nextNumber;
            newItem.Draft_Number__c = String.valueOf(nextNumber.intValue());
            newItem.Payment_Date__c = nextDate;
            newItem.Total_Payment__c = 0;
            newItem.Retainer_Fee_Amount__c = 0;
            newItem.Setup_Fee_Amount__c = 0;
            newItem.Program_Fee_Amount__c = 0;
            newItem.Banking_Fee_Amount__c = defaultBankingFee;
            newItem.Bank2_Fee_Amount__c = 0;
            newItem.Additional_Products_Amount__c = 0;
            newItem.Status__c = 'Scheduled';
            insert newItem;

            // Build wrapper
            ScheduleItemWrapper wrapper = new ScheduleItemWrapper();
            wrapper.id = newItem.Id;
            wrapper.rowNumber = nextNumber.intValue();
            wrapper.draftNumber = newItem.Draft_Number__c;
            wrapper.paymentDate = newItem.Payment_Date__c;
            wrapper.draftAmount = newItem.Total_Payment__c;
            wrapper.retainerFee = newItem.Retainer_Fee_Amount__c;
            wrapper.setupFee = newItem.Setup_Fee_Amount__c;
            wrapper.programFee = newItem.Program_Fee_Amount__c;
            wrapper.bankingFee = newItem.Banking_Fee_Amount__c;
            wrapper.banking2Fee = newItem.Bank2_Fee_Amount__c;
            wrapper.alertAmount = newItem.Additional_Products_Amount__c;
            wrapper.savingsBalance = 0;
            wrapper.toEscrowAmount = 0;
            wrapper.status = newItem.Status__c;
            wrapper.isNew = true;

            return wrapper;

        } catch (Exception e) {
            throw new AuraHandledException('Error adding payment row: ' + e.getMessage());
        }
    }

    /**
     * @description Delete multiple payment rows
     * @param itemIds List of Payment_Schedule_Item__c IDs to delete
     */
    @AuraEnabled
    public static void deletePaymentRows(List<Id> itemIds) {
        try {
            if (itemIds != null && !itemIds.isEmpty()) {
                delete [SELECT Id FROM Payment_Schedule_Item__c WHERE Id IN :itemIds];
            }
        } catch (Exception e) {
            throw new AuraHandledException('Error deleting payment rows: ' + e.getMessage());
        }
    }

    /**
     * @description Recalculate payment plan by fetching Opportunity data and creating a new version
     * Creates a new PaymentPlan__c with incremented version number and calculates all fee breakdowns
     * @param planId The current Payment Plan ID to base calculations on
     * @return PaymentPlanWrapper for the new version
     */
    @AuraEnabled
    public static PaymentPlanWrapper recalculatePaymentPlan(Id planId) {
        Savepoint sp = Database.setSavepoint();
        try {
            if (planId == null) {
                throw new AuraHandledException('Plan ID is required');
            }

            // Get current plan to find Opportunity and version number
            PaymentPlan__c currentPlan = [
                SELECT Id, Name, Opportunity__c, Version_Number__c, Program_Type__c
                FROM PaymentPlan__c
                WHERE Id = :planId
                LIMIT 1
            ];

            if (currentPlan.Opportunity__c == null) {
                throw new AuraHandledException('Payment Plan is not linked to an Opportunity');
            }

            // Get Opportunity data with all required fields
            Opportunity opp = [
                SELECT Id, Name, ContractId, Program_Type__c,
                       Setup_Fee__c, Setup_Fee_Term__c,
                       Total_Program__c, Program_Fee__c,
                       Est_weekly_payment__c, Estimated_Current_Payment__c,
                       Estimated_Total_Debt__c, Estimated_Settlement_to_Creditors__c,
                       Est_Settlement__c, Number_of_Weeks__c, First_Draft_Date__c,
                       No_Fee_Program__c
                FROM Opportunity
                WHERE Id = :currentPlan.Opportunity__c
                LIMIT 1
            ];

            // Get Banking Fee from CMDT config
            String programType = opp.Program_Type__c != null ? opp.Program_Type__c : currentPlan.Program_Type__c;
            PaymentCalcConfigSvc.ConfigDTO config;
            try {
                config = PaymentCalcConfigSvc.getRequiredConfigForProgram(programType);
            } catch (Exception configEx) {
                // Fall back to default config if program-specific fails
                config = PaymentCalcConfigSvc.getRequiredConfig();
            }

            Decimal bankingFee = config.bankingFee != null ? config.bankingFee : 15.00;
            Decimal bank2Fee = config.bank2Fee != null ? config.bank2Fee : 0;

            // Calculate new version number
            Decimal newVersionNumber = currentPlan.Version_Number__c != null ?
                currentPlan.Version_Number__c + 1 : 2;

            // Create new Payment Plan with data from Opportunity
            PaymentPlan__c newPlan = new PaymentPlan__c();
            newPlan.Opportunity__c = opp.Id;
            newPlan.Contract__c = opp.ContractId;
            newPlan.Program_Type__c = opp.Program_Type__c != null ? opp.Program_Type__c : currentPlan.Program_Type__c;

            // Map Opportunity fields to Payment Plan
            newPlan.Setup_Fee__c = opp.Setup_Fee__c;
            newPlan.Setup_Fee_Payments__c = parsePercentageToDecimal(opp.Setup_Fee_Term__c);
            newPlan.Program_Fee_Amount__c = opp.Total_Program__c;
            newPlan.Program_Fee_Percentage__c = parsePercentageToDecimal(opp.Program_Fee__c);
            newPlan.Weekly_Payment__c = opp.Est_weekly_payment__c;
            newPlan.Current_Payment__c = opp.Estimated_Current_Payment__c;
            newPlan.Total_Debt__c = opp.Estimated_Total_Debt__c;
            newPlan.Settlement_Amount__c = opp.Estimated_Settlement_to_Creditors__c;
            newPlan.Settlement_Percentage__c = parsePercentageToDecimal(opp.Est_Settlement__c);
            newPlan.Number_of_Payments__c = opp.Number_of_Weeks__c;
            newPlan.First_Payment_Date__c = opp.First_Draft_Date__c;

            // Set Banking Fee from CMDT
            newPlan.Banking_Fee__c = bankingFee;
            newPlan.Bank2_Fee__c = bank2Fee;

            // Version metadata
            newPlan.Version_Number__c = newVersionNumber;
            newPlan.Is_Active__c = false;
            newPlan.Previous_Version__c = currentPlan.Id;
            newPlan.Version_Type__c = 'Revision';
            newPlan.Source__c = 'UI';
            newPlan.Version_Notes__c = 'Recalculated from Opportunity on ' + DateTime.now().format();
            newPlan.Calculation_Timestamp__c = DateTime.now();

            insert newPlan;

            // Query existing schedule items from current plan for status-based redistribution
            List<Payment_Schedule_Item__c> existingItems = [
                SELECT Id, Payment_Number__c, Draft_Number__c, Payment_Date__c,
                       Total_Payment__c, Setup_Fee_Amount__c, Program_Fee_Amount__c,
                       Banking_Fee_Amount__c, Bank2_Fee_Amount__c, Additional_Products_Amount__c,
                       Retainer_Fee_Amount__c, To_Escrow_Amount__c, Savings_Balance__c, Status__c
                FROM Payment_Schedule_Item__c
                WHERE Payment_Plan__c = :planId
                ORDER BY Payment_Number__c ASC
            ];

            // Calculate and create schedule items (preserves non-scheduled, redistributes scheduled)
            List<Payment_Schedule_Item__c> scheduleItems = calculateScheduleItems(newPlan, opp, config, existingItems);

            if (!scheduleItems.isEmpty()) {
                insert scheduleItems;
            }

            // Update plan item count
            newPlan.Schedule_Item_Count__c = scheduleItems.size();
            update newPlan;

            return getPaymentPlanById(newPlan.Id);

        } catch (PaymentCalcConfigException configEx) {
            Database.rollback(sp);
            throw new AuraHandledException('Configuration error: ' + configEx.getMessage());
        } catch (Exception e) {
            Database.rollback(sp);
            throw new AuraHandledException('Error recalculating payment plan: ' + e.getMessage());
        }
    }

    /**
     * @description Parse a percentage string to Decimal value
     * Handles values like "35%", "35", "20%" by stripping the % symbol
     * @param value The string value to parse
     * @return Decimal value or null if blank/invalid
     */
    private static Decimal parsePercentageToDecimal(String value) {
        if (String.isBlank(value)) {
            return null;
        }
        try {
            String cleanValue = value.replace('%', '').trim();
            if (String.isBlank(cleanValue)) {
                return null;
            }
            return Decimal.valueOf(cleanValue);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * @description Wrapper class to hold paid sums from non-scheduled items
     * Used for redistribution calculations when recalculating payment plans
     */
    private class PaidSumsWrapper {
        public Decimal setupFee = 0;
        public Decimal programFee = 0;
        public Decimal escrow = 0;
        public Decimal savingsBalance = 0;
        public Integer nonScheduledCount = 0;
    }

    /**
     * @description Calculate schedule items with all fee breakdowns
     * Handles status-based recalculation: preserves non-scheduled rows (Paid/Missed/Cancelled)
     * and recalculates scheduled rows using the same split ratio formula as CalculationService.
     * Program fee cap is reduced by already collected amount from non-scheduled rows.
     * @param plan The Payment Plan to create items for
     * @param opp The Opportunity with source data
     * @param config The CMDT configuration
     * @param existingItems Existing schedule items from the current plan (can be null for fresh calculation)
     * @return List of Payment_Schedule_Item__c records (not yet inserted)
     */
    private static List<Payment_Schedule_Item__c> calculateScheduleItems(
        PaymentPlan__c plan,
        Opportunity opp,
        PaymentCalcConfigSvc.ConfigDTO config,
        List<Payment_Schedule_Item__c> existingItems
    ) {
        List<Payment_Schedule_Item__c> resultItems = new List<Payment_Schedule_Item__c>();

        // Get calculation parameters
        Integer numberOfPayments = plan.Number_of_Payments__c != null ?
            plan.Number_of_Payments__c.intValue() : 52;
        Date firstPaymentDate = plan.First_Payment_Date__c != null ?
            plan.First_Payment_Date__c : Date.today().addDays(7);
        Decimal weeklyPayment = plan.Weekly_Payment__c != null ? plan.Weekly_Payment__c : 0;

        // Get fee values
        Decimal totalSetupFee = plan.Setup_Fee__c != null ? plan.Setup_Fee__c : 0;
        Decimal setupFeePayments = plan.Setup_Fee_Payments__c != null ? plan.Setup_Fee_Payments__c : 4;
        Decimal perPaymentSetupFee = setupFeePayments > 0 ? (totalSetupFee / setupFeePayments) : 0;

        // Get fee values from CMDT (flat fees)
        Decimal bankingFee = plan.Banking_Fee__c != null ? plan.Banking_Fee__c : config.bankingFee;
        Decimal bank2Fee = plan.Bank2_Fee__c != null ? plan.Bank2_Fee__c : config.bank2Fee;

        // Get split ratios from CMDT config (matches CalculationService)
        Decimal programSplitRatio = config.programSplitRatio != null ? config.programSplitRatio : 0.50;

        // No Fee Program override
        Boolean isNoFeeProgram = opp.No_Fee_Program__c != null && opp.No_Fee_Program__c;
        if (isNoFeeProgram) {
            programSplitRatio = 0;
        }

        // Calculate total program fee from debt and percentage (matches CalculationService)
        Decimal totalDebt = plan.Total_Debt__c != null ? plan.Total_Debt__c : 0;
        Decimal programFeePercentage = plan.Program_Fee_Percentage__c != null ?
            plan.Program_Fee_Percentage__c : config.programFeePercent;
        Decimal totalProgramFee = totalDebt * (programFeePercentage / 100);

        // Separate existing items by status and calculate paid sums
        List<Payment_Schedule_Item__c> nonScheduledItems = new List<Payment_Schedule_Item__c>();
        List<Payment_Schedule_Item__c> scheduledItems = new List<Payment_Schedule_Item__c>();
        PaidSumsWrapper paidSums = new PaidSumsWrapper();

        if (existingItems != null && !existingItems.isEmpty()) {
            separateItemsByStatus(existingItems, nonScheduledItems, scheduledItems);
            paidSums = calculatePaidSums(nonScheduledItems);
        }

        // If no existing items or all items are scheduled, do fresh calculation
        if (existingItems == null || existingItems.isEmpty() || nonScheduledItems.isEmpty()) {
            return calculateFreshScheduleItems(plan, opp, config, numberOfPayments, firstPaymentDate);
        }

        // Calculate remaining program fee (cap reduced by already collected)
        Decimal remainingProgramFee = Math.max(0, totalProgramFee - paidSums.programFee);

        // Calculate remaining setup fee payments
        Integer paidSetupFeeCount = 0;
        for (Payment_Schedule_Item__c item : nonScheduledItems) {
            if (item.Setup_Fee_Amount__c != null && item.Setup_Fee_Amount__c > 0) {
                paidSetupFeeCount++;
            }
        }
        Integer remainingSetupFeePayments = Math.max(0, setupFeePayments.intValue() - paidSetupFeeCount);

        // Copy non-scheduled items first (preserve original values)
        for (Payment_Schedule_Item__c item : nonScheduledItems) {
            resultItems.add(cloneItemForNewPlan(item, plan.Id));
        }

        // Start running escrow balance from last paid row's balance
        Decimal runningEscrowBalance = paidSums.savingsBalance;
        Integer setupFeePaymentsMade = 0;

        // Create scheduled items using split ratio formula (matches CalculationService)
        for (Payment_Schedule_Item__c existingItem : scheduledItems) {
            Payment_Schedule_Item__c newItem = new Payment_Schedule_Item__c();
            newItem.Payment_Plan__c = plan.Id;
            newItem.Payment_Number__c = existingItem.Payment_Number__c;
            newItem.Draft_Number__c = existingItem.Draft_Number__c;
            newItem.Payment_Date__c = existingItem.Payment_Date__c;

            // Calculate setup fee for this payment (only for remaining setup fee payments)
            Decimal thisSetupFee = 0;
            if (setupFeePaymentsMade < remainingSetupFeePayments) {
                thisSetupFee = perPaymentSetupFee;
                setupFeePaymentsMade++;
            }

            // Banking fees are flat from CMDT
            Decimal thisBankingFee = bankingFee;
            Decimal thisBank2Fee = bank2Fee;

            // Calculate net amount available for program/escrow split (matches CalculationService)
            Decimal netAmount = weeklyPayment - thisBankingFee;

            // Calculate program fee and escrow using split ratios (matches CalculationService)
            Decimal thisProgramFee = 0;
            Decimal toEscrow = 0;

            if (remainingProgramFee > 0) {
                // Desired program amount based on split ratio
                Decimal desiredProgramFee = netAmount * programSplitRatio;
                // Cap at remaining program fee
                thisProgramFee = Math.min(desiredProgramFee, remainingProgramFee);
                // Escrow gets the rest of net amount
                toEscrow = netAmount - thisProgramFee;
                // Reduce remaining program fee
                remainingProgramFee -= thisProgramFee;
            } else {
                // All program fees collected, everything goes to escrow
                toEscrow = netAmount;
            }

            // Update running escrow balance
            runningEscrowBalance += toEscrow;

            // Total Payment = base weekly payment + setup fee (setup fee is ON TOP)
            Decimal totalPayment = weeklyPayment + thisSetupFee;

            // Set all fields
            newItem.Total_Payment__c = totalPayment;
            newItem.Setup_Fee_Amount__c = thisSetupFee;
            newItem.Program_Fee_Amount__c = thisProgramFee;
            newItem.Banking_Fee_Amount__c = thisBankingFee;
            newItem.Bank2_Fee_Amount__c = thisBank2Fee;
            newItem.Additional_Products_Amount__c = 0;
            newItem.Retainer_Fee_Amount__c = 0;
            newItem.To_Escrow_Amount__c = toEscrow;
            newItem.Savings_Balance__c = runningEscrowBalance;
            newItem.Status__c = 'Scheduled';

            resultItems.add(newItem);
        }

        // Sort by payment number to maintain order
        resultItems.sort();

        return resultItems;
    }

    /**
     * @description Overloaded method for backward compatibility (fresh calculation)
     */
    private static List<Payment_Schedule_Item__c> calculateScheduleItems(
        PaymentPlan__c plan,
        Opportunity opp,
        PaymentCalcConfigSvc.ConfigDTO config
    ) {
        return calculateScheduleItems(plan, opp, config, null);
    }

    /**
     * @description Calculate fresh schedule items without existing items
     * Used when there are no non-scheduled items to preserve
     */
    private static List<Payment_Schedule_Item__c> calculateFreshScheduleItems(
        PaymentPlan__c plan,
        Opportunity opp,
        PaymentCalcConfigSvc.ConfigDTO config,
        Integer numberOfPayments,
        Date firstPaymentDate
    ) {
        List<Payment_Schedule_Item__c> items = new List<Payment_Schedule_Item__c>();

        Decimal weeklyPayment = plan.Weekly_Payment__c != null ? plan.Weekly_Payment__c : 0;
        Decimal totalSetupFee = plan.Setup_Fee__c != null ? plan.Setup_Fee__c : 0;
        Decimal setupFeePayments = plan.Setup_Fee_Payments__c != null ? plan.Setup_Fee_Payments__c : 4;
        Decimal perPaymentSetupFee = setupFeePayments > 0 ? (totalSetupFee / setupFeePayments) : 0;

        Decimal bankingFee = plan.Banking_Fee__c != null ? plan.Banking_Fee__c : config.bankingFee;
        Decimal bank2Fee = plan.Bank2_Fee__c != null ? plan.Bank2_Fee__c : config.bank2Fee;

        Decimal programSplitRatio = config.programSplitRatio != null ? config.programSplitRatio : 0.50;

        Boolean isNoFeeProgram = opp.No_Fee_Program__c != null && opp.No_Fee_Program__c;
        if (isNoFeeProgram) {
            programSplitRatio = 0;
        }

        Decimal totalDebt = plan.Total_Debt__c != null ? plan.Total_Debt__c : 0;
        Decimal programFeePercentage = plan.Program_Fee_Percentage__c != null ?
            plan.Program_Fee_Percentage__c : config.programFeePercent;
        Decimal totalProgramFee = totalDebt * (programFeePercentage / 100);

        Decimal remainingProgramFee = totalProgramFee;
        Decimal runningEscrowBalance = 0;

        for (Integer i = 1; i <= numberOfPayments; i++) {
            Payment_Schedule_Item__c item = new Payment_Schedule_Item__c();
            item.Payment_Plan__c = plan.Id;
            item.Payment_Number__c = i;
            item.Draft_Number__c = String.valueOf(i);
            item.Payment_Date__c = firstPaymentDate.addDays((i - 1) * 7);

            Decimal thisSetupFee = (i <= setupFeePayments.intValue()) ? perPaymentSetupFee : 0;
            Decimal netAmount = weeklyPayment - bankingFee;

            Decimal thisProgramFee = 0;
            Decimal toEscrow = 0;

            if (remainingProgramFee > 0) {
                Decimal desiredProgramFee = netAmount * programSplitRatio;
                thisProgramFee = Math.min(desiredProgramFee, remainingProgramFee);
                toEscrow = netAmount - thisProgramFee;
                remainingProgramFee -= thisProgramFee;
            } else {
                toEscrow = netAmount;
            }

            runningEscrowBalance += toEscrow;

            item.Total_Payment__c = weeklyPayment + thisSetupFee;
            item.Setup_Fee_Amount__c = thisSetupFee;
            item.Program_Fee_Amount__c = thisProgramFee;
            item.Banking_Fee_Amount__c = bankingFee;
            item.Bank2_Fee_Amount__c = bank2Fee;
            item.Additional_Products_Amount__c = 0;
            item.Retainer_Fee_Amount__c = 0;
            item.To_Escrow_Amount__c = toEscrow;
            item.Savings_Balance__c = runningEscrowBalance;
            item.Status__c = 'Scheduled';

            items.add(item);
        }

        return items;
    }

    /**
     * @description Separate schedule items by status into scheduled and non-scheduled lists
     * Non-scheduled includes: Paid, Missed, Cancelled (anything except 'Scheduled')
     * @param allItems All items to separate
     * @param nonScheduledItems Output list for non-scheduled items
     * @param scheduledItems Output list for scheduled items
     */
    private static void separateItemsByStatus(
        List<Payment_Schedule_Item__c> allItems,
        List<Payment_Schedule_Item__c> nonScheduledItems,
        List<Payment_Schedule_Item__c> scheduledItems
    ) {
        for (Payment_Schedule_Item__c item : allItems) {
            if (item.Status__c == 'Scheduled') {
                scheduledItems.add(item);
            } else {
                nonScheduledItems.add(item);
            }
        }
    }

    /**
     * @description Calculate sum of amounts from non-scheduled items
     * @param nonScheduledItems List of non-scheduled items
     * @return PaidSumsWrapper containing all summed values
     */
    private static PaidSumsWrapper calculatePaidSums(List<Payment_Schedule_Item__c> nonScheduledItems) {
        PaidSumsWrapper sums = new PaidSumsWrapper();

        for (Payment_Schedule_Item__c item : nonScheduledItems) {
            sums.setupFee += item.Setup_Fee_Amount__c != null ? item.Setup_Fee_Amount__c : 0;
            sums.programFee += item.Program_Fee_Amount__c != null ? item.Program_Fee_Amount__c : 0;
            sums.escrow += item.To_Escrow_Amount__c != null ? item.To_Escrow_Amount__c : 0;
            sums.nonScheduledCount++;
        }

        // Get last savings balance from the highest payment number non-scheduled item
        Decimal maxPaymentNumber = 0;
        for (Payment_Schedule_Item__c item : nonScheduledItems) {
            if (item.Payment_Number__c != null && item.Payment_Number__c > maxPaymentNumber) {
                maxPaymentNumber = item.Payment_Number__c;
                sums.savingsBalance = item.Savings_Balance__c != null ? item.Savings_Balance__c : 0;
            }
        }

        return sums;
    }

    /**
     * @description Distribute an amount evenly across N payments with proper cents handling
     * First payment receives any remainder from rounding
     * @param totalAmount Total amount to distribute
     * @param count Number of payments to distribute across
     * @return List of distributed amounts
     */
    private static List<Decimal> distributeAmountEvenly(Decimal totalAmount, Integer count) {
        List<Decimal> distributed = new List<Decimal>();

        if (count <= 0 || totalAmount <= 0) {
            for (Integer i = 0; i < count; i++) {
                distributed.add(0);
            }
            return distributed;
        }

        // Calculate base amount per payment (rounded down to 2 decimal places)
        Decimal baseAmount = (totalAmount / count).setScale(2, RoundingMode.DOWN);

        // Calculate remainder (cents that need to go to first payment)
        Decimal remainder = totalAmount - (baseAmount * count);
        remainder = remainder.setScale(2, RoundingMode.HALF_UP);

        for (Integer i = 0; i < count; i++) {
            if (i == 0) {
                // First payment gets base amount plus remainder
                distributed.add(baseAmount + remainder);
            } else {
                distributed.add(baseAmount);
            }
        }

        return distributed;
    }

    /**
     * @description Clone a schedule item for a new payment plan
     * Preserves all field values but assigns to new plan
     * @param original Original item to clone
     * @param newPlanId New payment plan ID
     * @return Cloned item with new plan assignment
     */
    private static Payment_Schedule_Item__c cloneItemForNewPlan(
        Payment_Schedule_Item__c original,
        Id newPlanId
    ) {
        Payment_Schedule_Item__c cloned = new Payment_Schedule_Item__c();
        cloned.Payment_Plan__c = newPlanId;
        cloned.Payment_Number__c = original.Payment_Number__c;
        cloned.Draft_Number__c = original.Draft_Number__c;
        cloned.Payment_Date__c = original.Payment_Date__c;
        cloned.Total_Payment__c = original.Total_Payment__c;
        cloned.Setup_Fee_Amount__c = original.Setup_Fee_Amount__c;
        cloned.Program_Fee_Amount__c = original.Program_Fee_Amount__c;
        cloned.Banking_Fee_Amount__c = original.Banking_Fee_Amount__c;
        cloned.Bank2_Fee_Amount__c = original.Bank2_Fee_Amount__c;
        cloned.Additional_Products_Amount__c = original.Additional_Products_Amount__c;
        cloned.Retainer_Fee_Amount__c = original.Retainer_Fee_Amount__c;
        cloned.To_Escrow_Amount__c = original.To_Escrow_Amount__c;
        cloned.Savings_Balance__c = original.Savings_Balance__c;
        cloned.Status__c = original.Status__c;
        return cloned;
    }

    /**
     * @description Suspend a payment plan
     * Creates a new version with Scheduled items changed to Cancelled,
     * activates the new version, and archives the previous plan
     * @param planId The Payment Plan ID
     * @return PaymentPlanWrapper for the new suspended version
     */
    @AuraEnabled
    public static PaymentPlanWrapper suspendPaymentPlan(Id planId) {
        Savepoint sp = Database.setSavepoint();
        try {
            if (planId == null) {
                throw new AuraHandledException('Plan ID is required');
            }

            // Get the current plan with all fields
            PaymentPlan__c currentPlan = [
                SELECT Id, Name, Opportunity__c, Version_Number__c, Version_Status__c,
                       Is_Active__c, Version_Type__c, Source__c, Version_Notes__c,
                       Banking_Fee__c, Bank2_Fee__c, Setup_Fee__c, Setup_Fee_Payments__c,
                       Current_Payment__c, No_Fee_Program__c, Preferred_Day_of_Week__c,
                       Calculation_Timestamp__c, Schedule_Item_Count__c
                FROM PaymentPlan__c
                WHERE Id = :planId
                LIMIT 1
            ];

            // Get the next version number
            Integer maxVersion = 0;
            List<AggregateResult> maxVersionResult = [
                SELECT MAX(Version_Number__c) maxVer
                FROM PaymentPlan__c
                WHERE Opportunity__c = :currentPlan.Opportunity__c
            ];
            if (maxVersionResult.size() > 0 && maxVersionResult[0].get('maxVer') != null) {
                maxVersion = Integer.valueOf(maxVersionResult[0].get('maxVer'));
            }

            // Create new plan as a clone with incremented version
            PaymentPlan__c newPlan = currentPlan.clone(false, true, false, false);
            newPlan.Version_Number__c = maxVersion + 1;
            newPlan.Version_Status__c = 'Active';
            newPlan.Is_Active__c = true;
            newPlan.Version_Type__c = 'Suspension';
            newPlan.Source__c = 'UI';
            newPlan.Version_Notes__c = 'Plan suspended on ' + DateTime.now().format() + '. Scheduled items cancelled.';
            newPlan.Calculation_Timestamp__c = DateTime.now();
            insert newPlan;

            // Get all schedule items from the current plan
            List<Payment_Schedule_Item__c> currentItems = [
                SELECT Id, Payment_Number__c, Draft_Number__c, Payment_Date__c,
                       Total_Payment__c, Retainer_Fee_Amount__c, Setup_Fee_Amount__c,
                       Program_Fee_Amount__c, Banking_Fee_Amount__c, Bank2_Fee_Amount__c,
                       Additional_Products_Amount__c, Status__c, Savings_Balance__c,
                       To_Escrow_Amount__c
                FROM Payment_Schedule_Item__c
                WHERE Payment_Plan__c = :planId
                ORDER BY Payment_Number__c ASC
            ];

            // Clone items to new plan, changing Scheduled to Cancelled
            List<Payment_Schedule_Item__c> newItems = new List<Payment_Schedule_Item__c>();
            for (Payment_Schedule_Item__c item : currentItems) {
                Payment_Schedule_Item__c newItem = item.clone(false, true, false, false);
                newItem.Payment_Plan__c = newPlan.Id;

                // Change Scheduled status to Cancelled
                if (item.Status__c == 'Scheduled') {
                    newItem.Status__c = 'Cancelled';
                }

                newItems.add(newItem);
            }

            if (!newItems.isEmpty()) {
                insert newItems;
            }

            // Update the new plan's item count
            newPlan.Schedule_Item_Count__c = newItems.size();
            update newPlan;

            // Archive all other plans for this Opportunity (including the original)
            List<PaymentPlan__c> otherPlans = [
                SELECT Id, Version_Status__c, Is_Active__c
                FROM PaymentPlan__c
                WHERE Opportunity__c = :currentPlan.Opportunity__c
                AND Id != :newPlan.Id
            ];

            for (PaymentPlan__c otherPlan : otherPlans) {
                otherPlan.Version_Status__c = 'Archived';
                otherPlan.Is_Active__c = false;
            }

            if (!otherPlans.isEmpty()) {
                update otherPlans;
            }

            // Return the new plan with schedule items
            return buildPaymentPlanWrapper(newPlan, true);

        } catch (Exception e) {
            Database.rollback(sp);
            throw new AuraHandledException('Error suspending payment plan: ' + e.getMessage());
        }
    }

    /**
     * @description Activate a draft payment plan
     * Archives all previous versions and sets the selected plan as Active
     * @param planId The Payment Plan ID
     * @return Updated PaymentPlanWrapper
     */
    @AuraEnabled
    public static PaymentPlanWrapper activatePaymentPlan(Id planId) {
        Savepoint sp = Database.setSavepoint();
        try {
            if (planId == null) {
                throw new AuraHandledException('Plan ID is required');
            }

            // Get the plan to activate and its Opportunity ID
            PaymentPlan__c planToActivate = [
                SELECT Id, Opportunity__c, Version_Number__c
                FROM PaymentPlan__c
                WHERE Id = :planId
                LIMIT 1
            ];

            // Archive all other versions for this Opportunity
            List<PaymentPlan__c> otherPlans = [
                SELECT Id, Version_Status__c, Is_Active__c
                FROM PaymentPlan__c
                WHERE Opportunity__c = :planToActivate.Opportunity__c
                  AND Id != :planId
                  AND Version_Status__c != 'Archived'
            ];

            for (PaymentPlan__c otherPlan : otherPlans) {
                otherPlan.Version_Status__c = 'Archived';
                otherPlan.Is_Active__c = false;
            }

            if (!otherPlans.isEmpty()) {
                update otherPlans;
            }

            // Activate the selected plan
            PaymentPlan__c plan = new PaymentPlan__c(Id = planId);
            plan.Version_Status__c = 'Active';
            plan.Is_Active__c = true;
            plan.Calculation_Timestamp__c = DateTime.now();
            update plan;

            return getPaymentPlanById(planId);

        } catch (Exception e) {
            Database.rollback(sp);
            throw new AuraHandledException('Error activating payment plan: ' + e.getMessage());
        }
    }

    /**
     * @description Save pending items as a new version
     * Creates a new PaymentPlan__c and all Payment_Schedule_Item__c records
     * Archives the old plan and sets new plan as active
     * @param currentPlanId The current Payment Plan ID to clone from
     * @param items List of ScheduleItemWrapper objects from LWC
     * @return PaymentPlanWrapper for the new version
     */
    @AuraEnabled
    public static PaymentPlanWrapper saveAsNewVersion(Id currentPlanId, List<ScheduleItemWrapper> items) {
        Savepoint sp = Database.setSavepoint();
        try {
            if (currentPlanId == null) {
                throw new AuraHandledException('Plan ID is required');
            }
            if (items == null || items.isEmpty()) {
                throw new AuraHandledException('Items are required');
            }

            // Get current plan
            PaymentPlan__c currentPlan = [
                SELECT Id, Name, Opportunity__c, Contract__c, Program_Type__c,
                       Total_Debt__c, Settlement_Percentage__c, Program_Fee_Percentage__c,
                       Total_Program_Cost__c, Weekly_Payment__c, Monthly_Payment__c,
                       Number_of_Payments__c, First_Payment_Date__c, Status__c,
                       Version_Number__c, Version_Status__c, Is_Active__c,
                       Banking_Fee__c, Bank2_Fee__c, Setup_Fee__c, Setup_Fee_Payments__c,
                       Current_Payment__c, No_Fee_Program__c, Preferred_Day_of_Week__c,
                       Schedule_Item_Count__c
                FROM PaymentPlan__c
                WHERE Id = :currentPlanId
                LIMIT 1
            ];

            // Calculate new version number
            Decimal newVersionNumber = currentPlan.Version_Number__c != null ?
                currentPlan.Version_Number__c + 1 : 2;

            // Clone the plan as new version (save as Draft - user must activate manually)
            PaymentPlan__c newPlan = currentPlan.clone(false, true, false, false);
            newPlan.Version_Number__c = newVersionNumber;
            newPlan.Version_Status__c = 'Draft';
            newPlan.Is_Active__c = false;
            newPlan.Previous_Version__c = currentPlan.Id;
            newPlan.Version_Type__c = 'Revision';
            newPlan.Source__c = 'UI';
            newPlan.Version_Notes__c = 'Manual version created on ' + DateTime.now().format();
            newPlan.Calculation_Timestamp__c = DateTime.now();
            newPlan.Schedule_Item_Count__c = items.size();
            insert newPlan;

            // Create all schedule items for the new plan
            List<Payment_Schedule_Item__c> newItems = new List<Payment_Schedule_Item__c>();

            // Valid status values for Payment_Schedule_Item__c
            Set<String> validStatuses = new Set<String>{'Scheduled', 'Paid', 'Missed', 'Cancelled', 'Wire'};

            for (ScheduleItemWrapper item : items) {
                if (item.isDeleted) continue; // Skip deleted items

                Payment_Schedule_Item__c newItem = new Payment_Schedule_Item__c();
                newItem.Payment_Plan__c = newPlan.Id;
                newItem.Payment_Number__c = item.rowNumber;
                newItem.Draft_Number__c = item.draftNumber;
                newItem.Payment_Date__c = item.paymentDate;
                newItem.Total_Payment__c = item.draftAmount != null ? item.draftAmount : 0;
                newItem.Retainer_Fee_Amount__c = item.retainerFee != null ? item.retainerFee : 0;
                newItem.Setup_Fee_Amount__c = item.setupFee != null ? item.setupFee : 0;
                newItem.Program_Fee_Amount__c = item.programFee != null ? item.programFee : 0;
                newItem.Banking_Fee_Amount__c = item.bankingFee != null ? item.bankingFee : 0;
                newItem.Bank2_Fee_Amount__c = item.banking2Fee != null ? item.banking2Fee : 0;
                newItem.Additional_Products_Amount__c = item.alertAmount != null ? item.alertAmount : 0;

                // Preserve the original status from wrapper, validate it's a valid picklist value
                String itemStatus = item.status;
                if (String.isBlank(itemStatus) || !validStatuses.contains(itemStatus)) {
                    itemStatus = 'Scheduled'; // Default to Scheduled only if invalid
                }
                newItem.Status__c = itemStatus;

                // Preserve Savings Balance and To Escrow Amount
                newItem.Savings_Balance__c = item.savingsBalance != null ? item.savingsBalance : 0;
                newItem.To_Escrow_Amount__c = item.toEscrowAmount != null ? item.toEscrowAmount : 0;

                newItems.add(newItem);
            }

            if (!newItems.isEmpty()) {
                insert newItems;
            }

            // Update plan item count
            newPlan.Schedule_Item_Count__c = newItems.size();
            update newPlan;

            return getPaymentPlanById(newPlan.Id);

        } catch (Exception e) {
            Database.rollback(sp);
            throw new AuraHandledException('Error saving new version: ' + e.getMessage());
        }
    }

    // ============ PRIVATE HELPER METHODS ============

    /**
     * @description Build PaymentPlanWrapper from PaymentPlan__c record
     */
    private static PaymentPlanWrapper buildPaymentPlanWrapper(PaymentPlan__c plan, Boolean includeItems) {
        PaymentPlanWrapper wrapper = new PaymentPlanWrapper();
        wrapper.paymentPlan = plan;
        wrapper.versionNumber = plan.Version_Number__c != null ? plan.Version_Number__c.intValue() : 1;
        wrapper.versionStatus = plan.Version_Status__c;
        wrapper.isLatestVersion = true;

        if (includeItems) {
            List<Payment_Schedule_Item__c> items = [
                SELECT Id, Name, Payment_Number__c, Draft_Number__c, Payment_Date__c,
                       Total_Payment__c, Net_Draft_Amount__c, Retainer_Fee_Amount__c,
                       Setup_Fee_Amount__c, Program_Fee_Amount__c, Banking_Fee_Amount__c,
                       Bank2_Fee_Amount__c, Additional_Products_Amount__c, Status__c,
                       Savings_Balance__c, To_Escrow_Amount__c
                FROM Payment_Schedule_Item__c
                WHERE Payment_Plan__c = :plan.Id
                ORDER BY Payment_Number__c ASC
            ];

            Integer rowNum = 1;
            for (Payment_Schedule_Item__c item : items) {
                wrapper.scheduleItems.add(buildScheduleItemWrapper(item, rowNum++));
            }
        }

        return wrapper;
    }

    /**
     * @description Build ScheduleItemWrapper from Payment_Schedule_Item__c record
     */
    private static ScheduleItemWrapper buildScheduleItemWrapper(Payment_Schedule_Item__c item, Integer rowNum) {
        ScheduleItemWrapper wrapper = new ScheduleItemWrapper();
        wrapper.id = item.Id;
        wrapper.rowNumber = rowNum;
        wrapper.draftNumber = item.Draft_Number__c != null ? item.Draft_Number__c : String.valueOf(rowNum);
        wrapper.paymentDate = item.Payment_Date__c;
        wrapper.draftAmount = item.Total_Payment__c != null ? item.Total_Payment__c : item.Net_Draft_Amount__c;
        wrapper.retainerFee = item.Retainer_Fee_Amount__c;
        wrapper.setupFee = item.Setup_Fee_Amount__c;
        wrapper.programFee = item.Program_Fee_Amount__c;
        wrapper.bankingFee = item.Banking_Fee_Amount__c;
        wrapper.banking2Fee = item.Bank2_Fee_Amount__c;
        wrapper.alertAmount = item.Additional_Products_Amount__c;
        // Use To_Escrow_Amount__c field for Savings display
        wrapper.savingsBalance = item.To_Escrow_Amount__c != null ? item.To_Escrow_Amount__c : 0;
        wrapper.toEscrowAmount = item.To_Escrow_Amount__c != null ? item.To_Escrow_Amount__c : 0;
        wrapper.status = item.Status__c;
        return wrapper;
    }

    /**
     * @description Map wrapper fields to Payment_Schedule_Item__c record
     */
    private static void mapWrapperToRecord(ScheduleItemWrapper wrapper, Payment_Schedule_Item__c record) {
        record.Payment_Number__c = wrapper.rowNumber;
        record.Draft_Number__c = wrapper.draftNumber;
        record.Payment_Date__c = wrapper.paymentDate;
        record.Total_Payment__c = wrapper.draftAmount;
        record.Retainer_Fee_Amount__c = wrapper.retainerFee;
        record.Setup_Fee_Amount__c = wrapper.setupFee;
        record.Program_Fee_Amount__c = wrapper.programFee;
        record.Banking_Fee_Amount__c = wrapper.bankingFee;
        record.Bank2_Fee_Amount__c = wrapper.banking2Fee;
        record.Additional_Products_Amount__c = wrapper.alertAmount;
        record.Status__c = wrapper.status;
    }
}


================================================================================
NOTE: Test Class and LWC files are in separate documentation file due to size
================================================================================
See: PaymentPlanEditorCompleteCode_Part2.txt for:
- PaymentPlanEditorControllerTest.cls
- paymentPlanEditor.js
- paymentPlanEditor.html
- paymentPlanEditor.css
================================================================================
